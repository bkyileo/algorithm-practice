# coding=utf-8
__author__ = 'BK'
'''
小Hi实验室所在的建筑一楼有一个用于贴海报的黑板，不停的有新的海报往上贴，也会安排人员不断的对海报进行清理，而最近，轮到了小Hi去对海报进行清理。

黑板是一块W*H大小的区域，如果以左下角为直角坐标系的话，在上次清理后第i张贴上去的海报可以视作左下角为(X1i, Y1i)，右上角为(X2i, Y2i)的一个矩形。

撕去一张海报会导致所有覆盖在其上的海报都被同时撕掉，但是一张海报想要被撕掉的话需要至少存在一个角没有被其他海报覆盖（海报A被海报B覆盖当且仅当他们存在面积大于0的交集并且A在B之前贴出，海报A的一个角被海报B覆盖当且仅当这个顶点处于海报B的内部）。

于是现在问题来了，为了节约时间，小Hi决定一次性撕掉尽可能多的海报，那么他应该选择那张海报呢？在效果相同的情况下，小Hi倾向于选择更早贴出的海报。

输入
每个输入文件仅包含单组测试数据。

每组测试数据的第一行为三个正整数W，H和N，分别表示黑板的宽、高以及目前张贴出的海报数量。

接下来的N行，每行为四个正整数X1i、Y1i、X2i和Y2i，描述第i张贴出的海报。

对于20%的数据，满足1<=N<=5，1<=W,H<=10

对于100%的数据，满足1<=N<=1000，0<=X1i, X2i <= W, 0<=Y1i, Y2i<=H, 1<=W,H<=108

输出
对于每组测试数据，输出两个正整数Ans和K，表示小Hi一次最多能撕掉多少张海报，和他选择的海报是第几张贴出的。

样例输入
6 7 4
0 0 4 4
1 0 3 4
1 4 4 6
0 0 3 5
样例输出
3 1
'''
def check(x1,x2,y1,y2,wall):
    for i in xrange(x1,x2+1):
        for j in xrange(y1,y2+1):
            if wall[i][j]==0:
                return True
def func():
    w,h,n=raw_input().split()

    wall = [[0 for i in xrange(int(w))]for j in xrange(int(h))]

    posts=[]
    for i in xrange(int(n)):
        x1,y1,x2,y2=raw_input().split()
        posts.append((int(x1),int(y1),int(x2),int(y2)))

    print posts,wall

func()